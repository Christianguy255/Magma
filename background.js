/* ========================================================================
   PROJECT MAGMA - BACKGROUND SERVICE WORKER
   Version 2.8 - Opus API with CometApi
   ======================================================================== */

// Keep service worker alive
let keepAliveInterval = setInterval(() => {
  console.log('ðŸ”¥ Magma service worker alive');
}, 20000);

// Cache for API responses
const apiCache = new Map();
const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

// API Configuration for CometAPI (OpenAI-compatible)
// API Configuration for CometAPI (OpenAI-compatible)
const API_CONFIG = {
  endpoint: 'https://api.cometapi.com/v1/chat/completions',
  // Default to the highest reasoning model for code auditing
  model: 'gpt-5.2-codex',
  timeout: 30000,
  maxRetries: 3,
  retryDelay: 1000
};

// ... inside handleMagmaProcess ...
// If the user hasn't selected a model, use the high-performance 2026 standard


/**
 * Main message listener
 */
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  console.log('ðŸ“¨ Background received:', request.action);

  if (request.action === "process_magma") {
    handleMagmaProcess(request.payload, sendResponse);
    return true; // Keep connection open for async response
  }

  return false;
});

/**
 * Process Magma request with feature loss detection
 */
/**
 * UPDATED: Process Magma request with Dynamic Model Selection
 */
/**
 * UPDATED: Process Magma request with Dynamic Model Selection
 */
async function handleMagmaProcess(payload, sendResponse) {
  const { mode, original, newCode, filename, instruction } = payload;

  try {
    // 1. FETCH API KEY AND SELECTED MODEL
    let storage = await chrome.storage.local.get(['selectedModel', 'cometApiKey']);
    let apiKey = storage.cometApiKey;
    let activeModel = storage.selectedModel || 'claude-opus-4-5-20251101';

    // --- FIX: AUTO-CORRECT STALE STORAGE ---
    // If storage has the old broken name, force update it to the new one
    if (activeModel === 'claude-4-opus') {
      console.log("ðŸ§¹ Cleaning up stale model name...");
      activeModel = 'claude-opus-4-5-20251101';
      chrome.storage.local.set({ selectedModel: activeModel });
    }
    // ---------------------------------------

    if (!apiKey) {
      throw new Error('CometAPI key is missing. Please open the extension popup and save your key.');
    }

    console.log(`ðŸš€ Magma Engine firing up with model: ${activeModel}`);

    // For completely new files, we don't need a feature loss check
    if (!original || original.trim() === '') {
      sendResponse({
        success: true,
        mergedCode: newCode,
        featureLoss: { hasLoss: false, explanation: "New file creation." }
      });
      return;
    }

    // 2. PREPARE PROMPT
    const systemPrompt = `You are a Senior Code Architect. Compare the ORIGINAL code with the NEW code generated by an AI.
Detect if any features, logic, or functionality from the ORIGINAL were accidentally removed or broken in the NEW version.

Return a JSON object:
{
  "hasLoss": boolean,
  "lostFeatures": ["feature 1", "feature 2"],
  "changedFeatures": ["description of logic changes"],
  "addedFeatures": ["new features found"],
  "explanation": "Brief summary of the audit",
  "recommendation": "What should the user do?"
}`;

    const userPrompt = `
FILE: ${filename}
INSTRUCTION GIVEN TO AI: ${instruction}

ORIGINAL CODE:
${original}

NEW CODE PROPOSED:
${newCode}

Perform a feature audit now.`;

    // 3. EXECUTE API CALL
    const response = await fetch(API_CONFIG.endpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiKey}`,
        'anthropic-beta': 'effort-2025-11-24',
        'X-Comet-Source': 'Project-Magma'
      },
      body: JSON.stringify({
        model: activeModel,
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: userPrompt }
        ],
        output_config: { "effort": "high" }
      })
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(errorData.error?.message || `API Request failed with status ${response.status}`);
    }

    const data = await response.json();
    let featureLoss;

    try {
      const content = data.choices[0].message.content;
      const jsonStr = content.replace(/```json\n?|\n?```/g, '').trim();
      featureLoss = JSON.parse(jsonStr);
    } catch (e) {
      console.error("Failed to parse AI audit JSON:", e);
      featureLoss = {
        hasLoss: false,
        explanation: "Audit complete, but results were in an unexpected format."
      };
    }

    // 4. SEND RESPONSE
    sendResponse({
      success: true,
      mergedCode: newCode,
      featureLoss: featureLoss,
      usedModel: activeModel
    });

  } catch (error) {
    console.error('âŒ Magma Process Error:', error);
    sendResponse({
      success: false,
      error: error.message
    });
  }
}

/**
 * Process with merge after user confirms (separate message)
 */
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  if (request.action === "process_with_merge") {
    handleMergeAfterWarning(request.payload, sendResponse);
    return true;
  }
});

async function handleMergeAfterWarning(payload, sendResponse) {
  const { mode, original, newCode, filename, instruction } = payload;

  try {
    const { cometApiKey } = await chrome.storage.local.get(['cometApiKey']);

    let result;
    if (mode === 'replace') {
      result = await processReplaceWithAPI(original, newCode, filename, cometApiKey);
    } else if (mode === 'insert') {
      result = await processInsertWithAPI(original, newCode, instruction, filename, cometApiKey);
    }

    sendResponse({
      success: true,
      result: result,
      apiCalled: true
    });

  } catch (error) {
    console.error("âŒ Merge error:", error);
    sendResponse({
      success: false,
      error: error.message
    });
  }
}

/**
 * Detect feature loss - separate Gemini API call
 */
async function detectFeatureLoss(original, newCode, apiKey) {
  try {
    // ALWAYS ask AI to analyze - let Claude Opus decide everything
    console.log("ðŸ” Asking Claude Opus 4.5 to analyze code changes...");

    const prompt = `You are an expert code analyst. Compare these two code versions and provide detailed analysis.

ORIGINAL CODE:
\`\`\`
${original}
\`\`\`

NEW CODE:
\`\`\`
${newCode}
\`\`\`

CRITICAL INSTRUCTIONS:
1. List ALL changes you detect (additions, removals, modifications)
2. Identify if ANY functionality is lost or at risk
3. Be SUSPICIOUS - flag anything that might be a problem
4. If code is just refactored/optimized with same functionality, say so
5. If features are removed, list them specifically

Respond with ONLY valid JSON:

{
  "hasLoss": true/false,
  "lostFeatures": ["specific feature 1", "specific feature 2"],
  "addedFeatures": ["new feature 1", "new feature 2"],
  "changedFeatures": ["modified feature 1"],
  "explanation": "Detailed analysis of what changed and why it matters",
  "recommendation": "Should user proceed, merge, or cancel?"
}

Examples:

If features removed:
{
  "hasLoss": true,
  "lostFeatures": ["handleSubmit function", "validation logic", "error handling"],
  "addedFeatures": [],
  "changedFeatures": [],
  "explanation": "The new code removes the form submission handler and all validation. This will break form functionality.",
  "recommendation": "merge"
}

If refactored safely:
{
  "hasLoss": false,
  "lostFeatures": [],
  "addedFeatures": ["TypeScript types"],
  "changedFeatures": ["Converted to arrow functions", "Added async/await"],
  "explanation": "Code has been refactored to modern syntax with better type safety. All original functionality is preserved.",
  "recommendation": "proceed"
}

If suspicious changes:
{
  "hasLoss": true,
  "lostFeatures": [],
  "addedFeatures": [],
  "changedFeatures": ["Simplified error handling"],
  "explanation": "The error handling has been simplified which may reduce robustness. Review recommended.",
  "recommendation": "merge"
}`;

    const response = await callCometAPI(prompt, apiKey);

    try {
      const jsonMatch = response.match(/\{[\s\S]*\}/);
      if (!jsonMatch) {
        console.warn("âŒ No JSON in AI response");
        return {
          hasLoss: true,
          lostFeatures: ["Could not analyze - AI response unclear"],
          addedFeatures: [],
          changedFeatures: [],
          explanation: "AI failed to analyze code properly",
          recommendation: "manual review needed"
        };
      }

      const parsed = JSON.parse(jsonMatch[0]);

      // Ensure all fields exist
      return {
        hasLoss: parsed.hasLoss || false,
        lostFeatures: parsed.lostFeatures || [],
        addedFeatures: parsed.addedFeatures || [],
        changedFeatures: parsed.changedFeatures || [],
        explanation: parsed.explanation || "No explanation provided",
        recommendation: parsed.recommendation || "proceed"
      };

    } catch (parseError) {
      console.warn("âŒ JSON parse error:", parseError);
      return {
        hasLoss: true,
        lostFeatures: ["Parse error - could not analyze"],
        addedFeatures: [],
        changedFeatures: [],
        explanation: "Failed to parse AI response",
        recommendation: "manual review needed"
      };
    }

  } catch (error) {
    console.error("âŒ Feature detection error:", error);
    return {
      hasLoss: true,
      lostFeatures: ["API error - analysis failed"],
      addedFeatures: [],
      changedFeatures: [],
      explanation: "Could not connect to AI for analysis: " + error.message,
      recommendation: "manual review needed"
    };
  }
}

/**
 * Process replace mode with API (merge code)
 */
async function processReplaceWithAPI(original, newCode, filename, apiKey) {
  const prompt = `You are a code merging assistant. Merge the new code into the original while preserving ALL original functionality.

ORIGINAL CODE (preserve all features):
\`\`\`
${original}
\`\`\`

NEW CODE (integrate improvements):
\`\`\`
${newCode}
\`\`\`

TASK: Create merged code that:
1. Keeps ALL functions/features from original
2. Integrates improvements from new code
3. Maintains all imports/exports
4. Preserves all logic

CRITICAL: Return ONLY the final code, NO explanations, NO markdown, ONLY CODE.`;

  const response = await callCometAPI(prompt, apiKey);

  // Clean response - remove markdown if present
  let cleaned = response.trim();
  cleaned = cleaned.replace(/```[a-z]*\n/g, ''); // Remove opening ```
  cleaned = cleaned.replace(/```\s*$/g, '');      // Remove closing ```

  return cleaned;
}

/**
 * Process insert mode with API
 */
async function processInsertWithAPI(original, newCode, instruction, filename, apiKey) {
  const prompt = `You are a code insertion assistant. Insert new code into existing code at the correct location.

ORIGINAL CODE:
\`\`\`
${original}
\`\`\`

CODE TO INSERT:
\`\`\`
${newCode}
\`\`\`

INSERTION INSTRUCTION: ${instruction || "Insert at appropriate location"}

TASK: Insert the new code while:
1. Preserving ALL original code
2. Placing new code at correct location
3. Maintaining proper indentation
4. Keeping all imports/logic

CRITICAL: Return ONLY the final code, NO explanations, NO markdown, ONLY CODE.`;

  const response = await callCometAPI(prompt, apiKey);

  // Clean response
  let cleaned = response.trim();
  cleaned = cleaned.replace(/```[a-z]*\n/g, '');
  cleaned = cleaned.replace(/```\s*$/g, '');

  return cleaned;
}

/**
 * Call Google Gemini Flash API
 */
async function callCometAPI(prompt, apiKey, retryCount = 0) {
  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), API_CONFIG.timeout);

    const response = await fetch(API_CONFIG.endpoint, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: API_CONFIG.model,
        messages: [
          { role: 'user', content: prompt }
        ],
        temperature: 0.3,
        max_tokens: 4096
      }),
      signal: controller.signal
    });

    clearTimeout(timeoutId);

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`CometAPI error ${response.status}: ${errorText}`);
    }

    const data = await response.json();

    // OpenAI-compatible format
    if (data.choices && data.choices[0] && data.choices[0].message) {
      return data.choices[0].message.content.trim();
    } else {
      throw new Error("Unexpected API response format");
    }

  } catch (error) {
    if (error.name === 'AbortError') {
      throw new Error('Request timeout - API took too long to respond');
    }

    // Retry logic
    if (retryCount < API_CONFIG.maxRetries) {
      console.log(`ðŸ”„ Retry ${retryCount + 1}/${API_CONFIG.maxRetries}`);
      await sleep(API_CONFIG.retryDelay * Math.pow(2, retryCount));
      return await callCometAPI(prompt, apiKey, retryCount + 1);
    }

    throw error;
  }
}

/**
 * Insert code directly without API (when no feature loss)
 */
function insertCodeDirectly(original, newCode, instruction) {
  if (!instruction) {
    // Default: insert after imports
    const lines = original.split('\n');
    let insertIndex = 0;

    for (let i = 0; i < lines.length; i++) {
      if (lines[i].trim().startsWith('import ') ||
        lines[i].trim().startsWith('from ') ||
        lines[i].trim().startsWith('const ') ||
        lines[i].trim().startsWith('let ')) {
        insertIndex = i + 1;
      } else if (insertIndex > 0 && lines[i].trim() === '') {
        break;
      }
    }

    lines.splice(insertIndex, 0, '', newCode, '');
    return lines.join('\n');
  }

  const lower = instruction.toLowerCase();
  if (lower.includes('beginning') || lower.includes('start') || lower.includes('top')) {
    return newCode + '\n\n' + original;
  } else if (lower.includes('end') || lower.includes('bottom')) {
    return original + '\n\n' + newCode;
  } else {
    // Default to after imports
    return insertCodeDirectly(original, newCode, null);
  }
}

/**
 * Hash function for cache keys
 */
function hashCode(str) {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash;
  }
  return hash.toString(36);
}

/**
 * Sleep utility
 */
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// Clear old cache entries periodically
setInterval(() => {
  const now = Date.now();
  for (const [key, value] of apiCache.entries()) {
    if (now - value.timestamp > CACHE_DURATION) {
      apiCache.delete(key);
    }
  }
}, CACHE_DURATION);

// Log when installed
chrome.runtime.onInstalled.addListener(() => {
  console.log('ðŸ”¥ Magma Background Service Worker installed - CometAPI');
});

console.log('ðŸ”¥ Magma Background Service Worker loaded - CometAPI ready');
